# Введение в SQL

# Узнайте, как использовать SQL для чтения и манипулирования данными в реляционной базе данных.

# Использование SQL для чтения и записи в базу данных

Изучите основные концепции реляционных баз данных и научитесь использовать SQL для чтения и работы с базой данных.

# Использование SQL для чтения и записи в базу данных

### Прежде чем начать

Многие из используемых вами приложений хранят данные непосредственно на устройстве. Приложение «Часы» хранит повторяющиеся будильники, приложение «Карты Google» сохраняет список последних поисков, а приложение «Контакты» позволяет добавлять, редактировать и удалять информацию о контактах.

Постоянство данных - хранение или сохранение данных на устройстве - является важной частью разработки Android. Благодаря постоянству данных пользовательский контент не теряется при закрытии приложения, а данные, загруженные из Интернета, сохраняются, чтобы их не нужно было загружать заново.

SQLite - это распространенный способ хранения данных, предоставляемый Android SDK для Android-приложений. SQLite представляет собой реляционную базу данных, которая позволяет представлять данные аналогично тому, как вы структурируете данные с помощью классов Kotlin. В этом коделабе изучаются основы языка SQL-Structured Query Language, который, хотя и не является настоящим языком программирования, обеспечивает простой и гибкий способ чтения и модификации базы данных SQLite с помощью всего нескольких строк кода.

Получив фундаментальные знания SQL, вы будете готовы использовать библиотеку Room для добавления постоянства в ваши приложения, о чем мы расскажем далее в этом разделе.

> Примечание: В приложениях для Android есть несколько способов хранения данных, включая внутренние и внешние хранилища. В этом разделе рассматриваются Room и Preferences Datastore. Чтобы узнать больше о различных методах хранения данных в Android, обратитесь к обзору хранения данных и файлов.

### Ключевые понятия реляционных баз данных

Что такое база данных?
Если вы знакомы с программой для работы с электронными таблицами, например Google Sheets, то вы уже знакомы с базовой аналогией базы данных.

Электронная таблица состоит из отдельных таблиц данных или отдельных электронных таблиц в одной рабочей книге.


![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/1f2b00d3ca083c4a_856.png)

Каждая таблица состоит из столбцов, которые определяют, что представляют собой данные, и строк, в которых представлены отдельные элементы со значениями для каждого столбца. Например, вы можете определить столбцы для идентификатора, имени, специальности и оценки студента.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/a441da5cc7be346b_856.png)

Каждая строка содержит данные об одном студенте со значениями для каждого из столбцов.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/6131d8a59996f521_856.png)

Реляционная база данных работает аналогичным образом.

Таблицы определяют высокоуровневые группы данных, которые вы хотите представить, например, студенты и преподаватели.
Столбцы определяют данные, которые содержит каждая строка таблицы.
Строки содержат фактические данные, состоящие из значений для каждого столбца таблицы.
Структура реляционной базы данных также отражает то, что вы уже знаете о классах и объектах в Kotlin.


```kt
data class Student(
    id: Int,
    name: String,
    major: String,
    gpa: Double
)
```

Классы, как и таблицы, моделируют данные, которые вы хотите представить в своем приложении.
Свойства, например столбцы, определяют конкретные части данных, которые должен содержать каждый экземпляр класса.
Объекты, как и строки, представляют собой фактические данные. Объекты содержат значения для каждого свойства, определенного в классе, так же как строки содержат значения для каждого столбца, определенного в таблице данных.
Как электронная таблица может содержать несколько листов, а приложение - несколько классов, так и база данных может содержать несколько таблиц. База данных называется реляционной, если она может моделировать отношения между таблицами. Например, аспирант может иметь одного профессора в качестве консультанта по докторской диссертации, в то время как этот профессор является консультантом по докторской диссертации для нескольких студентов.


![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/7f1b56e05520dc3_856.png)

Каждая таблица в реляционной базе данных содержит уникальный идентификатор для строк, например, столбец, значение которого в каждой строке является автоматически увеличивающимся целым числом. Этот идентификатор известен как первичный ключ.

Когда таблица ссылается на первичный ключ другой таблицы, это называется внешним ключом. Наличие внешнего ключа означает, что между таблицами существует связь.

> Примечание: Как и в случае с классами Kotlin, принято использовать форму единственного числа для названия таблиц базы данных. Для приведенного выше примера это означает, что вы называете таблицы teacher, student и course, а не множественные формы teachers, students и courses.


Что такое SQLite?
SQLite - это широко используемая реляционная база данных. Точнее, SQLite - это облегченная библиотека на языке Си для управления реляционными базами данных с помощью языка структурированных запросов, известного как SQL и иногда произносимого как «сиквел» для краткости.

Для работы с реляционной базой данных вам не придется изучать C или какой-либо совершенно новый язык программирования. SQL - это просто способ добавлять и извлекать данные из реляционной базы данных с помощью нескольких строк кода.

> Примечание: Не все базы данных организованы в виде таблиц, столбцов и строк. Другие виды баз данных, известные как NoSQL, структурированы аналогично объекту JSON с вложенными парами ключей и значений. Примерами баз данных NoSQL являются Redis или Cloud Firestore.

Представление данных с помощью SQLite
В Kotlin вы знакомы с такими типами данных, как Int и Boolean. Базы данных SQLite тоже используют типы данных! Колонки таблицы данных должны иметь определенный тип данных. В следующей таблице приведено соответствие распространенных типов данных Kotlin их эквивалентам в SQLite.


|Kotlin data type|SQLite data type|
|:---------------|:---------------|
|Int|INTEGER|
|String|VARCHAR or TEXT|
|Boolean|BOOLEAN|
|Float, Double|REAL|

Таблицы в базе данных и столбцы в каждой таблице называются схемой. В следующем разделе вы загрузите стартовый набор данных и узнаете больше о его схеме.

# 3. Загрузка стартового набора данных

В качестве базы данных для этого коделаба используется гипотетическое приложение для работы с электронной почтой. В этом коделабе используются знакомые примеры, такие как сортировка и фильтрация почты, поиск по тексту темы или отправителя, чтобы продемонстрировать все мощные возможности, которые можно сделать с помощью SQL. Этот пример также поможет вам получить опыт работы с теми типами сценариев, которые вы можете встретить в приложении, прежде чем вы начнете работать с Room на следующем пути.

Загрузите начальный проект из ветки compose репозитория SQL Basics GitHub здесь.

Использование инспектора баз данных
Чтобы воспользоваться инспектором баз данных, выполните следующие действия:

Запустите приложение SQL Basics в Android Studio. При запуске приложения вы увидите следующее окно.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/76e94dfe2234c2b1_856.png)

В Android Studio нажмите View > Tool Windows > App Inspection.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/cd5dd859d31cbab3_856.png)

Теперь вы видите новую вкладку App Inspection с выбранной вкладкой Database Inspector. Есть еще две дополнительные вкладки, но они вам не понадобятся. Загрузка может занять несколько секунд, но затем вы увидите список слева с таблицами данных, которые можно выбрать для выполнения запросов.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/5ace24ac5cc15abc_856.png)

Нажмите кнопку Open New Query Tab, чтобы открыть панель для запуска запроса к базе данных.



![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/277ecff401ca5f1a_856.png)

Таблица email содержит 7 столбцов:

id: Первичный ключ.
тема: Тема письма.
отправитель: Адрес электронной почты, с которого было отправлено письмо.
папка: Папка, в которой можно найти сообщение, например «Входящие» или «Спам».
звездочка: Отметил ли пользователь письмо звездочкой.
прочитано: Прочитал ли пользователь письмо.
получено: Временная метка, когда письмо было получено.


> Совет: Нажмите кнопку Keep Database Connections Open c344609191760f79.png, чтобы продолжить взаимодействие с базой данных после выключения эмулятора.
![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/582d2d5ec3a738e0_856.png)


# 4. Чтение данных с помощью оператора SELECT

Оператор SQL SELECT

Оператор SQL - иногда его называют запросом - используется для чтения или манипулирования базой данных.

Вы читаете данные из базы данных SQLite с помощью оператора SELECT. Простой оператор SELECT состоит из ключевого слова SELECT, затем имени столбца, затем ключевого слова FROM, затем имени таблицы. Каждый оператор SQL заканчивается точкой с запятой (;).

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/2d7ff99736b072b9_856.png )


Оператор SELECT может также возвращать данные из нескольких столбцов. Имена столбцов следует разделять запятой.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/cf94edd5de825043_856.png)

Если необходимо выбрать каждый столбец из таблицы, вместо имен столбцов используется символ подстановки (*).

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/fb75d3033c59949a_856.png)

В любом случае простой оператор SELECT, подобный этому, возвращает каждую строку в таблице. Вам просто нужно указать имена столбцов, которые вы хотите вернуть.


> Примечание: Несмотря на то, что по правилам каждый SQL-запрос должен заканчиваться точкой с запятой (;), некоторые редакторы, например, инспектор баз данных в Android Studio, позволяют опустить точку с запятой. На диаграммах в этом учебном пособии точка с запятой ставится в конце каждого полного SQL-запроса.

Чтение данных электронной почты с помощью оператора SELECT
Одна из основных задач приложения для работы с электронной почтой - отображение списка сообщений. В базе данных SQL эту информацию можно получить с помощью оператора SELECT.

Убедитесь, что таблица email выбрана в инспекторе базы данных.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/ffc77f938ea09071_856.png)

Сначала попробуйте выбрать каждый столбец из каждой строки таблицы email.

```
SELECT * FROM email;
```

Нажмите кнопку Run в правом нижнем углу текстового поля. Обратите внимание, что возвращается вся таблица электронной почты.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/4c3ea237c6ed2b57_856.png)

Теперь попробуйте выбрать только тему для каждой строки.

```
SELECT subject FROM email;
```

Обратите внимание, что запрос снова возвращает все строки, но только для одного столбца.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/69a20935721dcc2_856.png)

Вы также можете выбрать несколько столбцов. Попробуйте выбрать тему и отправителя.

```
SELECT subject, sender FROM email;
```


Обратите внимание, что запрос возвращает все строки таблицы email, но только значения столбцов subject и sender.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/4ae739dad54397ea_856.png)

Поздравляем! Вы только что выполнили свой первый запрос. Неплохо, но считайте, что это только начало; «привет мир» SQL, если хотите.

Операторы SELECT могут быть гораздо более конкретными, добавляя условия для определения подмножества данных и даже изменяя форматирование вывода. В следующих разделах вы узнаете о часто используемых пунктах операторов SELECT и о том, как форматировать данные.

# 5. Использование операторов SELECT с агрегатными функциями и отличительными значениями

Сокращение столбцов с помощью агрегатных функций
Операторы SQL не ограничиваются возвратом строк. SQL предлагает множество функций, которые могут выполнять операции или вычисления над определенным столбцом, например, находить максимальное значение или подсчитывать количество уникальных значений для определенного столбца. Эти функции называются агрегатными. Вместо того чтобы возвращать все данные определенного столбца, вы можете вернуть одно значение из определенного столбца.

Примеры агрегатных функций SQL включают следующее:

COUNT(): Возвращает общее количество строк, соответствующих запросу.
SUM(): Возвращает сумму значений для всех строк в выбранном столбце.
AVG(): Возвращает среднее значение-среднее значение всех значений в выбранном столбце.
MIN(): Возвращает наименьшее значение в выбранном столбце.
MAX(): Возвращает наибольшее значение в выбранном столбце.
Вместо имени столбца можно вызвать агрегатную функцию и передать имя столбца в качестве аргумента между скобками.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/6730a62d583a0d9_856.png)

Вместо того чтобы возвращать значение этого столбца для каждой строки таблицы, при вызове агрегатной функции возвращается одно значение.


Агрегатные функции могут быть эффективным способом выполнения вычислений над значением, когда вам не нужно читать все данные в базе данных. Например, вы можете захотеть найти среднее значение в столбце, не загружая всю базу данных в List и не делая это вручную.

Давайте посмотрим на некоторые агрегатные функции в действии на примере таблицы электронной почты:

Приложение может захотеть получить общее количество полученных писем. Это можно сделать с помощью функции COUNT() и символа подстановки (*).

``kt
SELECT COUNT(*) FROM email;
```

Запрос возвращает одно значение. Вы можете сделать это полностью с помощью SQL-запроса, без какого-либо кода Kotlin для подсчета строк вручную.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/5d49b987545184bb_856.png)

Чтобы получить время самого последнего сообщения, можно использовать функцию MAX() для столбца received, поскольку самая последняя временная метка Unix - это наибольшее число.

SELECT MAX(received) FROM email;

Запрос возвращает один результат - самую последнюю временную метку в столбце received.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/d0241dce845c3955_856.png)

Фильтр дублирующихся результатов с помощью DISTINCT
Когда вы выбираете столбец, перед ним можно поставить ключевое слово DISTINCT. Такой подход может быть полезен, если вы хотите удалить дубликаты из результатов запроса.


![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/4f02533256302f26_856.png)

Например, во многих почтовых приложениях есть функция автозаполнения адресов. Возможно, вы захотите включить все адреса, с которых вы получаете электронные письма, и отобразить их в виде списка.

Выполните следующий запрос, чтобы вернуть столбец «Отправитель» для каждой строки.

``SELECT sender FROM email;``

Обратите внимание, что результат содержит множество дубликатов. Это определенно не идеальный опыт!

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/4f0489d1668dbede_856.png)

Добавьте ключевое слово DISTINCT перед столбцом sender и выполните запрос заново.

``SELECT DISTINCT sender FROM email;``

Обратите внимание, что результат теперь намного меньше, а каждое значение уникально.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/43a47ad8d18fee6e_856.png)

Перед именем столбца в агрегатной функции также можно поставить ключевое слово DISTINCT.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/55c45cb9c258e882_856.png)

Допустим, вы хотите узнать количество уникальных отправителей в базе данных. Вы можете подсчитать количество уникальных отправителей с помощью агрегатной функции COUNT() и ключевого слова DISTINCT для столбца sender.


Выполните оператор SELECT, передав функции COUNT() значение DISTINCT sender.

``SELECT COUNT(DISTINCT sender) FROM email;``

Обратите внимание, что запрос сообщает нам, что существует 14 уникальных отправителей.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/19ae43b0bc9a927e_856.png)

# 6. Фильтр запросов с помощью предложения WHERE

Многие почтовые приложения предлагают функцию фильтрации отображаемых сообщений по определенным критериям, таким как данные, поисковый запрос, папка, отправитель и т. д. Для таких случаев вы можете добавить в запрос SELECT предложение WHERE.

После имени таблицы в новой строке можно добавить ключевое слово WHERE, за которым следует выражение. При написании более сложных SQL-запросов принято выносить каждое предложение на новую строку для удобства чтения.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/707b0641aa2de0f_856.png)

Этот запрос выполняет булеву проверку для каждой выбранной строки; если проверка возвращает true, то строка включается в результат запроса. Строки, для которых запрос возвращает false, не включаются в результат.

Например, в почтовом приложении могут быть фильтры для спама, корзины, черновиков или созданные пользователем фильтры. В следующих инструкциях это делается с помощью предложения WHERE:

Выполните оператор SELECT, чтобы вернуть все столбцы (*) из таблицы электронной почты, включая предложение WHERE для проверки условия folder = 'inbox'. Нет, это не опечатка: для проверки равенства в SQL используется одинарный знак равенства, а для представления строкового значения - одинарные, а не двойные кавычки.

``kt
SELECT * FROM email
WHERE folder = 'inbox';
```

Результат возвращает строки только для сообщений в папке «Входящие» пользователя.


![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/6e9f2a17186d7faa_856.png)

> Примечание: Обратите особое внимание на операторы сравнения в SQL!

В отличие от Kotlin, оператор сравнения в SQL - это одинарный знак равенства (=), а не двойной знак равенства (==).
Оператор неравенства (!=) такой же, как и в Kotlin. SQL также предоставляет операторы сравнения <, <=, > и >=.

Логические операторы в предложениях WHERE
Клаузы SQL WHERE не ограничиваются одним выражением. Вы можете использовать ключевое слово AND, эквивалентное оператору Kotlin and (&&), чтобы включить только те результаты, которые удовлетворяют обоим условиям.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/d8a698416e55d11b_856.png)

В качестве альтернативы можно использовать ключевое слово OR, эквивалентное оператору Kotlin or (||), чтобы включить в результаты строки, удовлетворяющие любому из условий.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/f3cecac289e7650d_856.png)

Для удобства чтения можно также отрицать выражение с помощью ключевого слова NOT.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/27300a0a38ef0343_856.png)

Многие приложения для работы с электронной почтой позволяют использовать несколько фильтров, например, показывать только непрочитанные письма.

Попробуйте использовать следующие более сложные условия WHERE для таблицы email:

Помимо возврата только сообщений в папке входящих сообщений пользователя, попробуйте также ограничить результаты непрочитанными сообщениями, если значение столбца read равно false.

```
SELECT * FROM email
WHERE folder = 'inbox' AND read = false;
```

Обратите внимание, что после выполнения запроса результаты содержат только непрочитанные письма в папке «Входящие» пользователя.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/d9ebd307a146d320_856.png)

Возвращает все письма, которые находятся в папке «Важные» ИЛИ отмечены звездочками (starred = true). Это означает, что результат включает письма в разных папках, если они отмечены звездочками.

```
SELECT * FROM email
WHERE folder = 'important' OR starred = true;
```
Наблюдайте за результатом.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/fd2f0dc7b6444956_856.png)

> Примечание: Вы также можете записать условие SQL NOT folder = 'spam' как folder != 'spam'.

Поиск текста с помощью LIKE
Одна суперполезная вещь, которую можно сделать с помощью предложения WHERE, - это поиск текста в определенном столбце. Для этого нужно указать имя столбца, затем ключевое слово LIKE, а затем строку поиска.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/6692c0d491b6f9af_856.png)

Строка поиска начинается с символа процента (%), затем следует текст для поиска (Search term), затем снова символ процента (%).

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/c69c15f654645ee2_856.png)

Если вы ищете префикс - результаты, которые начинаются с указанного текста, - первый символ процента (%) исключается.


![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/fbe6a94daaf173ae_856.png)

Кроме того, если вы ищете суффикс, опустите последний символ процента (%).

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/141f567c9cbc4029_856.png)

Существует множество вариантов использования текстового поиска в приложениях, например поиск писем, содержащих определенный текст в строке темы, или обновление предложений автозаполнения по мере ввода текста пользователем.

Следующие инструкции позволят вам использовать текстовый поиск при запросе к таблице электронной почты.

Персонажи Шекспира, как и персонажи нашей базы данных, любили говорить о дураках. Выполните следующий запрос, чтобы получить общее количество писем с текстом «дурак» в строке темы.

``kt
SELECT COUNT(*) FROM email
WHERE subject LIKE '%fool%';
```

Наблюдайте за результатом.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/fd2ff96969824b0d_856.png)

Выполните следующий запрос, чтобы вернуть все столбцы из всех строк, в которых тема заканчивается словом fool.

```
SELECT * FROM email
WHERE subject LIKE '%fool';
```

Обратите внимание, что возвращаются две строки.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/a23379e507e39c0b_856.png)

Выполните следующий запрос, чтобы вернуть отдельные значения столбца sender, начинающиеся с буквы h.

```
SELECT DISTINCT sender FROM email
WHERE sender LIKE 'h%';
```

Обратите внимание, что запрос возвращает три значения: helena@example.com , hyppolytus@example.com и hermia@example.com.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/47ada07aee5cd8d9_856.png)

# 7. Группировка, упорядочивание и ограничение результатов

Группировка результатов с помощью GROUP BY
Вы только что узнали, как использовать агрегатные функции и предложение WHERE для фильтрации и сокращения результатов. SQL предлагает несколько других предложений, которые могут помочь вам отформатировать результаты запроса. Среди них группировка, упорядочивание и ограничение результатов.

Вы можете использовать предложение GROUP BY для группировки результатов таким образом, чтобы все строки, имеющие одинаковое значение для данного столбца, были сгруппированы рядом друг с другом в результатах. Это предложение не изменяет результаты, а только порядок их возврата.

Чтобы добавить предложение GROUP BY в оператор SELECT, добавьте ключевое слово GROUP BY, за которым следует имя столбца, по которому вы хотите сгруппировать результаты.


![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/6be095e981498bbf_856.png)

Чаще всего используется сочетание предложения GROUP BY с агрегатной функцией, чтобы разделить результат агрегатной функции по разным группам, например, по значениям столбцов. Вот пример. Представьте, что вы хотите получить количество писем в каждой папке: «Входящие», «Спам» и т. д. Вы можете выбрать как столбец папок, так и агрегатную функцию COUNT(), а также указать столбец папок в предложении GROUP BY.

Выполните следующий запрос, чтобы выбрать столбец папок и результат агрегатной функции COUNT(). Используйте предложение GROUP BY, чтобы разделить результаты по значению в столбце папок.

``kt
SELECT folder, COUNT(*) FROM email
GROUP BY folder;
```

Наблюдайте за результатами. Запрос возвращает общее количество писем для каждой папки.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/13b9eb8f5c8230c4_856.png)

> Примечание: В предложении GROUP BY можно указать несколько столбцов, разделенных запятой, если вы хотите разделить каждую группу на дополнительные подгруппы, основанные на разных столбцах.

Сортировка результатов с помощью ORDER BY
Вы также можете изменить порядок результатов запроса, отсортировав их с помощью предложения ORDER BY. Добавьте ключевое слово ORDER BY, затем имя столбца и направление сортировки.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/9cf561c6346ed6e0_856.png)

По умолчанию направлением сортировки является порядок возрастания, который можно опустить в предложении ORDER BY. Если вы хотите, чтобы результаты были отсортированы в порядке убывания, добавьте DESC после имени столбца.

Скорее всего, вы ожидаете, что приложение электронной почты будет показывать в первую очередь самые последние письма. Следующие инструкции позволят вам сделать это с помощью предложения ORDER BY.

Добавьте предложение ORDER BY для сортировки непрочитанных писем на основе столбца «Полученные». Поскольку по умолчанию используется порядок по возрастанию - младшие или старшие по возрасту, необходимо использовать ключевое слово DESC.

```
SELECT * FROM email
ORDER BY received DESC;
```

Понаблюдайте за результатом.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/6e28aef784a16d1b_856.png)

Можно использовать предложение ORDER BY вместе с предложением WHERE. Скажем, пользователь хочет найти старые письма, содержащие текст fool. Можно отсортировать результаты, чтобы сначала отображались самые старые письма в порядке возрастания.

Выберите все письма, в теме которых содержится текст «дурак», и отсортируйте результаты по возрастанию. Поскольку порядок сортировки является возрастающим и используется по умолчанию, если не указан ни один порядок, использование ключевого слова ASC в предложении ORDER BY необязательно.


```
SELECT * FROM email
WHERE subject LIKE '%fool%'
ORDER BY received ASC;
```

Обратите внимание, что отфильтрованные результаты возвращаются с самым старым наименьшим значением в полученном столбце, показанным первым.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/77ada71b663afab6_856.png)

> Примечание: Если в одном запросе используются оба варианта, то предложение GROUP BY идет перед предложением ORDER BY.

Ограничение количества результатов с помощью LIMIT

До сих пор все примеры возвращали все результаты из базы данных, соответствующие запросу. Во многих случаях вам нужно отобразить только ограниченное количество строк из базы данных. Вы можете добавить в запрос предложение LIMIT, чтобы вернуть только определенное количество результатов. Добавьте ключевое слово LIMIT, за которым следует максимальное количество строк, которые вы хотите вернуть. Если применимо, предложение LIMIT следует после предложения ORDER BY.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/122152adf15a9fca_856.png)

В качестве опции можно включить ключевое слово OFFSET, за которым следует другое число, обозначающее количество строк, которые нужно «пропустить». Например, если вам нужны следующие десять результатов после первых десяти, но вы не хотите возвращать все двадцать результатов, вы можете использовать LIMIT 10 OFFSET 10.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/37ad836862573d55_856.png)

В качестве опции вы можете включить ключевое слово OFFSET, за которым следует другое число, обозначающее количество строк, которые нужно «пропустить». Например, если вам нужны следующие десять результатов после первых десяти, но вы не хотите возвращать все двадцать результатов, вы можете использовать LIMIT 10 OFFSET 10.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/37ad836862573d55_856.png)

В приложении вы можете захотеть быстрее загружать электронные письма, возвращая только первые десять писем в папке входящих сообщений пользователя. Затем пользователи могут прокручивать страницу, чтобы просмотреть последующие письма. В следующих инструкциях для достижения такого поведения используется предложение LIMIT.

Выполните следующий оператор SELECT, чтобы получить все письма в папке «Входящие» пользователя в порядке убывания и ограничиться первыми десятью результатами.

``kt
SELECT * FROM email
WHERE folder = 'inbox'
ORDER BY received DESC
LIMIT 10;
```

Обратите внимание, что возвращается только десять результатов.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/5b228d8053956489_856.png)

Измените и повторно выполните запрос, включив в него ключевое слово OFFSET со значением 10.

```
SELECT * FROM email
WHERE folder = 'inbox'
ORDER BY received DESC
LIMIT 10 OFFSET 10;
```

Запрос возвращает десять результатов в порядке убывания. Однако запрос пропускает первый набор из десяти результатов.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/83a6ddbf6ef92b89_856.png)



# 8. Вставка, обновление и удаление данных в базе данных
Вставка данных в базу данных
Помимо чтения из базы данных, существуют различные операторы SQL для записи в базу данных. Ведь данные должны как-то туда попасть, не так ли?

Добавить новую строку в базу данных можно с помощью оператора INSERT. Оператор INSERT начинается с INSERT INTO, за которым следует имя таблицы, в которую вы хотите вставить новую строку. Ключевое слово VALUES появляется на новой строке, за которым следует набор круглых скобок, содержащих список значений, разделенных запятыми. Значения нужно перечислять в том же порядке, что и столбцы базы данных.


![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/97b93929d6de2d0e_856.png)

Представьте, что пользователь получил новое письмо, и нам нужно сохранить его в базе данных нашего приложения. Мы можем использовать оператор INSERT для добавления новой строки в таблицу email.

Выполните оператор INSERT со следующими данными для нового письма. Поскольку письмо новое, оно непрочитанное и первоначально появляется в папке «Входящие». Для столбца id указано значение NULL, что означает, что id будет автоматически сгенерирован из следующего доступного целого числа с автоинкрементацией.

```
INSERT INTO email
VALUES (
    NULL, 'Lorem ipsum dolor sit amet', 'sender@example.com', 'inbox', false, false, CURRENT_TIMESTAMP
);
```

> Примечание: CURRENT_TIMESTAMP - это специальная переменная, которая при выполнении запроса заменяется на текущее время в UTC, что удобно при вставке новых строк!

Обратите внимание, что результат вставляется в базу данных с идентификатором 44.

``ql
SELECT * FROM email
WHERE sender = 'sender@example.com';
```

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/12a3e77309771dd8_856.png)

Обновление существующих данных в базе данных
После того как вы вставили данные в таблицу, вы можете изменить их позже. Для этого можно обновить значение одного или нескольких столбцов с помощью оператора UPDATE. Оператор UPDATE начинается с ключевого слова UPDATE, за которым следует имя таблицы, а затем предложение SET.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/8ee88a5985aec77e_856.png)

Предложение SET состоит из ключевого слова SET, за которым следует имя столбца, который необходимо обновить.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/bc255ece789859f_856.png)

Оператор UPDATE часто включает предложение WHERE для указания одной или нескольких строк, которые необходимо обновить с помощью указанной пары столбец-значение.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/e64b7b343feb6224_856.png)

Если, например, пользователь хочет пометить электронное письмо как прочитанное, для обновления базы данных используется оператор UPDATE. Следующие инструкции позволяют пометить электронное письмо, вставленное в предыдущем шаге, как прочитанное.

Выполните следующий оператор UPDATE, чтобы установить для строки с идентификатором 44 значение столбца read равным true.

``ql
UPDATE email
SET read = true
WHERE id = 44;
```

Запустите оператор SELECT для этой конкретной строки, чтобы проверить результат.

```ql
SELECT read FROM email
WHERE id = 44;
```

Обратите внимание, что значение столбца read теперь равно 1 для «истинного» значения, а не 0 для «ложного».

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/74e9af167fa49ba3_856.png)

Удаление строки из базы данных
Наконец, вы можете использовать оператор SQL DELETE для удаления одной или нескольких строк из таблицы. Оператор DELETE начинается с ключевого слова DELETE, за которым следует ключевое слово FROM, затем имя таблицы, после чего следует предложение WHERE, указывающее, какую строку или строки вы хотите удалить.


![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/a7e56405c5e5aaab_856.png)

В следующих инструкциях используется оператор DELETE для удаления из базы данных ранее вставленной и впоследствии обновленной строки.

Выполните следующий оператор DELETE, чтобы удалить из базы данных строку с идентификатором 44.

``ql
DELETE FROM email
WHERE id = 44;
```

Проверьте изменения с помощью оператора SELECT.

```sql
SELECT * FROM email
WHERE id = 44;
```

Обратите внимание, что строка с идентификатором 44 больше не существует.

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/b026810cf2fd6e44_856.png)


### Резюме

Поздравляем! Вы многому научились! Теперь вы можете считывать данные из базы данных с помощью операторов SELECT, включая предложения WHERE, GROUP BY, ORDER BY и LIMIT для фильтрации результатов. Вы также узнали о часто используемых агрегатных функциях, ключевом слове DISTINCT для указания уникальных результатов и ключевом слове LIKE для выполнения текстового поиска по значениям в столбце. Наконец, вы узнали, как выполнять INSERT, UPDATE и DELETE строк в таблице данных.

Эти навыки можно напрямую перенести в Room, и, зная SQL, вы будете более чем готовы к работе с данными в своих будущих приложениях.

Синтаксис оператора SELECT:

![](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-sql/img/346bed4fda774ca7_856.png)
