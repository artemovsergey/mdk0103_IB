# Практика: Классы и коллекции

# Прежде чем начать

В этом разделе вы узнали о дженериках, различных типах классов, коллекциях и функциях высшего порядка. Чтобы отработать полученные знания, вы поможете своей команде улучшить новое приложение для отслеживания событий. В инструкциях к каждому шагу описывается текущее состояние приложения и задача, которую вы должны выполнить.

Для решения этих упражнений рекомендуется использовать Kotlin Playground.

### Предварительные условия

- Пройдите первый этап Главы 3 курса «Основы Android с Compose» и предшествующие ему этапы.

- Знакомство с основами языка программирования Kotlin, включая классы, объекты, коллекции и функции высшего порядка.

### Что вам понадобится

- Компьютер с доступом в Интернет
- Доступ к Kotlin Playground

# Обзор приложения

Вы - новый инженер-программист в команде разработчиков приложения для отслеживания событий. Цель этого приложения - дать пользователям возможность отслеживать свои события. Ваша команда будет давать вам задания, чтобы помочь создать функциональность приложения.

В конце каждой задачи вы должны сравнить свое решение с предложенным. Добиться желаемой функциональности можно разными способами, поэтому не переживайте, если ваш код не будет полностью совпадать с предоставленным кодом решения.

Используйте код решения, предоставленный в предыдущем задании, в качестве начального кода для следующего задания, чтобы начать с общей точки отсчета.

# 3. Задача 1

Другой инженер-программист уже выполнил некоторую высокоуровневую работу над приложением, и вам поручено реализовать детали.

Вам необходимо реализовать класс Event. Этот класс используется для хранения информации о событии, введенном пользователем. (Подсказка: этот класс не должен определять никаких методов или выполнять какие-либо действия).

Для этой задачи вам нужно создать класс данных с именем Event.

Экземпляр этого класса должен уметь хранить:

Название события в виде строки.
Описание события в виде строки (может быть null).
День события в виде строки. Нам нужно отслеживать только то, началось ли событие утром, днем или вечером.
Продолжительность события в минутах как целое число.
Прежде чем продолжить, попробуйте написать код самостоятельно.

Используя свой код, создайте экземпляр, используя следующую информацию:

Название: Study Kotlin
Описание: Обязуюсь изучать Kotlin не менее 15 минут в день.
Дневная часть: Вечер
Продолжительность: 15
Попробуйте напечатать свой объект и убедитесь, что вы получите следующий результат:

Event(title=Изучение Kotlin, description=Обязательство изучать Kotlin не менее 15 минут в день., daypart=Evening, durationInMinutes=15)
После того как вы выполните задание или сделаете все возможное, нажмите кнопку Next, чтобы посмотреть, как мы его выполнили.


# 4. Решение задачи 1
Ваше решение должно выглядеть следующим образом:

```kt
data class Event(
    val title: String,
    val description: String? = null,
    val daypart: String,
    val durationInMinutes: Int,
)
```


# 5. Задание 2
Чтобы не срывать проект, ваш руководитель решает использовать код, который мы предоставили для класса данных.

После того как члены вашей команды некоторое время использовали класс Event, старший член команды понял, что использование строки для части дня не является идеальным.

Некоторые разработчики сохраняли значение «Morning», другие использовали «morning», а третьи - «MORNING».

Это вызвало множество проблем.

Ваша задача - исправить эту проблему, проведя рефакторинг. Рефакторинг - это процесс улучшения кода без изменения его функциональности. В качестве примера можно привести упрощение логики или перенос повторяющегося кода в отдельные функции.

Какой тип класса можно использовать для моделирования ограниченного набора различных значений, чтобы исправить эту проблему?

Ваша команда хочет, чтобы вы изменили код daypart и использовали класс enum. Используя класс перечисления, члены вашей команды будут вынуждены выбирать одно из предоставленных значений daypart, что предотвратит подобные проблемы.

Класс перечисления должен называться Daypart. Он должен иметь три значения:

MORNING
AFTERNOON
EVENING

Как бы вы создали этот класс перечисления?
Как бы вы рефакторизовали свой класс Event, чтобы использовать его?
Прежде чем продолжить, попробуйте закодировать свое решение.
Нажмите кнопку Next, чтобы увидеть, как мы его создали.


# 6. Решение задачи 2


```kt
enum class Daypart {
    MORNING,
    AFTERNOON,
    EVENING,
}
```

Рефакторинговый класс данных Event теперь использует класс enum:


```kt
data class Event(
    val title: String,
    val description: String? = null,
    val daypart: Daypart,
    val durationInMinutes: Int,
)
```


# 7. Задача 3
Ваши коллеги с удовольствием пользуются рефакторингом Daypart, но у них есть другие проблемы.

В настоящее время они создают и хранят события пользователя с помощью следующего кода.


```kt
val event1 = Event(title = "Wake up", description = "Time to get up", daypart = Daypart.MORNING, durationInMinutes = 0)
val event2 = Event(title = "Eat breakfast", daypart = Daypart.MORNING, durationInMinutes = 15)
val event3 = Event(title = "Learn about Kotlin", daypart = Daypart.AFTERNOON, durationInMinutes = 30)
val event4 = Event(title = "Practice Compose", daypart = Daypart.AFTERNOON, durationInMinutes = 60)
val event5 = Event(title = "Watch latest DevBytes video", daypart = Daypart.AFTERNOON, durationInMinutes = 10)
val event6 = Event(title = "Check out latest Android Jetpack library", daypart = Daypart.EVENING, durationInMinutes = 45)
```

Они создали множество событий, и для каждого из них в настоящее время требуется своя переменная. По мере создания новых событий становится все труднее отслеживать их. Используя этот подход, насколько сложно будет определить, сколько событий запланировал пользователь?

Можете ли вы придумать лучший способ организовать хранение этих событий?

Каким образом можно хранить все события в одной переменной? (Примечание: она должна быть гибкой, поскольку в нее могут добавляться новые события. Она также должна эффективно возвращать подсчет количества событий, хранящихся в переменной).

Какой класс или тип данных вы бы использовали? Каков один из способов добавления новых событий?

Теперь ваша очередь реализовать эту функцию. Попробуйте написать код, прежде чем нажать кнопку Next, чтобы увидеть наше решение.


# 8. Решение задачи 3


```kt
val events = mutableListOf<Event>(event1, event2, event3, event4, event5, event6)
```

# Задание 4
Вашему руководителю нравится, как идет работа над приложением, но он решил, что пользователь должен иметь возможность видеть сводку своих коротких событий, основанную на их продолжительности. Например, «У вас 5 коротких событий».

Короткое» событие - это событие, которое длится менее 60 минут.

Используя код переменной events из решения предыдущей задачи, как бы вы добились такого результата?

Примечание: Возможно, вам поможет решение этой задачи в несколько шагов. Как бы вы отфильтровали события по их продолжительности? После того как вы отфильтруете нужные события, как вы определите их количество?

Нажмите кнопку Next, чтобы перейти к нашему решению.



# 10. Решение задачи 4
Есть несколько способов решить эту задачу, и мы остановились на следующем:


```kt
val shortEvents = events.filter { it.durationInMinutes < 60 }
println("You have ${shortEvents.size} short events.")
```


# 11. Задание 5
Вашим коллегам нравится, как идет работа над приложением, но они хотят, чтобы пользователи могли видеть сводку всех событий и их даты.

Результат должен быть похож на:


```
Morning: 3 events
Afternoon: 4 events
Evening: 2 events
```

Используя код переменной событий из предыдущего шага, как вы можете достичь этого результата?

> Примечание: Возможно, вам поможет решение этой задачи в несколько шагов. Эта задача похожа на предыдущую, только вместо того, чтобы разделить события на две группы, нужно разделить их на несколько групп. Как сгруппировать события по дням недели? Как подсчитать количество событий в каждой части дня, если они сгруппированы?

Нажмите кнопку Next, чтобы увидеть код решения.

# 12. Решение задачи 5
Ниже приведено наше решение, но возможны и другие варианты.


```kt
val groupedEvents = events.groupBy { it.daypart }
groupedEvents.forEach { (daypart, events) ->
    println("$daypart: ${events.size} events")
}
```

# 13. Задача 6
В настоящее время ваш коллега находит и печатает последний элемент, используя его индекс. Используется следующий код: println(«Последнее событие дня: ${events[events.size - 1].title}»).

Ваш руководитель предлагает посмотреть документацию по Kotlin в поисках функции, которая могла бы упростить этот код.

Какую функцию вы нашли?

Попробуйте использовать ее, чтобы убедиться, что вы получите те же результаты, что и при печати.

Нажмите кнопку Далее, чтобы увидеть решение.



# 14. Task 6 Solution

```kt
println("Last event of the day: ${events.last().title}")
```

# 15. Задание 7
Вашей команде нравится класс данных, который вы разработали, но она считает, что писать код каждый раз, когда им нужна длительность события в виде строки, очень утомительно:


```kt
val durationOfEvent = if (events[0].durationInMinutes < 60) {
        "short"
    } else {
        "long"
    }
println("Duration of first event of the day: $durationOfEvent")
```

Хотя вы могли бы исправить это повторение, добавив метод непосредственно в класс, это не идеальный вариант, поскольку другие команды начали использовать ваш класс событий в своих приложениях. Если класс изменится, им придется перепроверять весь свой код, чтобы убедиться, что ничего не сломалось из-за вашего изменения.

Не меняя напрямую класс данных, как можно написать свойство расширения, возвращающее те же значения, что и в приведенном выше коде?

При правильной реализации вы сможете использовать следующий код, и он выведет то же сообщение, что и код, показанный в начале этой задачи.


```kt
println("Duration of first event of the day: ${events[0].durationOfEvent}")
```

Нажмите кнопку Далее, чтобы перейти к решению.



# 16. Task 7 Solution

```kt
val Event.durationOfEvent: String
    get() = if (this.durationInMinutes < 60) {
        "short"
    } else {
        "long"
    }
```